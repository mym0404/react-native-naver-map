import { Callout } from 'nextra/components'
import { WIP } from '../../lib/components/WIP';

# 마커 클러스터링

<WIP/>

많은 수의 마커를 효율적으로 표시하기 위한 클러스터링 구현 방법을 안내합니다.

<Callout type="info">
  마커 클러스터링은 지도 상의 가까운 거리에 있는 여러 마커들을 하나의 클러스터로 묶어 표시하는 기법입니다.
  성능 향상과 더 나은 사용자 경험을 제공합니다.
</Callout>

## 기본 클러스터링 구현

### 1. 클러스터링 라이브러리 설치

```bash
npm install react-native-super-cluster
# 또는
yarn add react-native-super-cluster
```

### 2. 클러스터링 Hook 구현

```tsx filename="useMarkerClustering.ts"
import { useMemo } from 'react';
import SuperCluster from 'react-native-super-cluster';

interface MarkerData {
  id: string;
  latitude: number;
  longitude: number;
  title?: string;
}

interface ClusterPoint {
  type: 'Feature';
  properties: MarkerData & {
    cluster?: boolean;
    cluster_id?: number;
    point_count?: number;
  };
  geometry: {
    type: 'Point';
    coordinates: [number, number];
  };
}

export const useMarkerClustering = (
  markers: MarkerData[],
  region: {
    latitude: number;
    longitude: number;
    latitudeDelta: number;
    longitudeDelta: number;
  }
) => {
  const superCluster = useMemo(() => {
    return new SuperCluster({
      radius: 40,
      maxZoom: 16,
      minZoom: 0,
      extent: 512,
      nodeSize: 64,
    });
  }, []);

  const clusters = useMemo(() => {
    const points: ClusterPoint[] = markers.map(marker => ({
      type: 'Feature',
      properties: marker,
      geometry: {
        type: 'Point',
        coordinates: [marker.longitude, marker.latitude],
      },
    }));

    superCluster.load(points);

    const bbox = [
      region.longitude - region.longitudeDelta,
      region.latitude - region.latitudeDelta,
      region.longitude + region.longitudeDelta,
      region.latitude + region.latitudeDelta,
    ];

    const zoom = Math.round(Math.log(360 / region.longitudeDelta) / Math.LN2);

    return superCluster.getClusters(bbox, zoom);
  }, [markers, region, superCluster]);

  return clusters;
};
```

### 3. 클러스터링 적용된 지도 컴포넌트

```tsx filename="ClusteredMapView.tsx"
import React, { useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { NaverMapView, NaverMapMarkerOverlay, Region } from '@mj-studio/react-native-naver-map';
import { useMarkerClustering } from './useMarkerClustering';

interface MarkerData {
  id: string;
  latitude: number;
  longitude: number;
  title?: string;
}

interface Props {
  markers: MarkerData[];
  initialRegion: Region;
}

export const ClusteredMapView: React.FC<Props> = ({ markers, initialRegion }) => {
  const [region, setRegion] = useState(initialRegion);

  const clusters = useMarkerClustering(markers, region);

  const renderClusterMarker = (cluster: any) => {
    const { cluster: isCluster, point_count } = cluster.properties;
    const [longitude, latitude] = cluster.geometry.coordinates;

    if (isCluster) {
      return (
        <NaverMapMarkerOverlay
          key={`cluster-${cluster.properties.cluster_id}`}
          latitude={latitude}
          longitude={longitude}
          anchor={{ x: 0.5, y: 0.5 }}
          width={50}
          height={50}
        >
          <View style={styles.clusterContainer}>
            <Text style={styles.clusterText}>{point_count}</Text>
          </View>
        </NaverMapMarkerOverlay>
      );
    }

    return (
      <NaverMapMarkerOverlay
        key={cluster.properties.id}
        latitude={latitude}
        longitude={longitude}
        anchor={{ x: 0.5, y: 1 }}
        caption={{ text: cluster.properties.title || '' }}
      />
    );
  };

  return (
    <NaverMapView
      style={{ flex: 1 }}
      initialRegion={initialRegion}
      onCameraChanged={(event) => {
        setRegion({
          latitude: event.latitude,
          longitude: event.longitude,
          latitudeDelta: event.contentBounds.northEast.latitude - event.contentBounds.southWest.latitude,
          longitudeDelta: event.contentBounds.northEast.longitude - event.contentBounds.southWest.longitude,
        });
      }}
    >
      {clusters.map(renderClusterMarker)}
    </NaverMapView>
  );
};

const styles = StyleSheet.create({
  clusterContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    backgroundColor: '#FF6B6B',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    borderColor: 'white',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  clusterText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
});
```

## 고급 클러스터링 기능

### 클러스터 터치 이벤트 처리

```tsx filename="InteractiveClusteredMap.tsx"
const handleClusterPress = (cluster: any) => {
  const { cluster: isCluster, cluster_id } = cluster.properties;

  if (isCluster) {
    // 클러스터를 확대하여 개별 마커들을 표시
    const expansionZoom = Math.min(
      superCluster.getClusterExpansionZoom(cluster_id),
      16
    );

    // 카메라를 해당 위치로 이동
    mapRef.current?.animateCameraTo({
      latitude: cluster.geometry.coordinates[1],
      longitude: cluster.geometry.coordinates[0],
      zoom: expansionZoom,
    });
  } else {
    // 개별 마커 터치 처리
    console.log('Marker tapped:', cluster.properties);
  }
};
```

### 동적 클러스터 스타일링

```tsx filename="DynamicClusterStyling.tsx"
const getClusterStyle = (pointCount: number) => {
  if (pointCount >= 100) {
    return {
      backgroundColor: '#FF4444',
      width: 60,
      height: 60,
      borderRadius: 30,
    };
  } else if (pointCount >= 10) {
    return {
      backgroundColor: '#FF8800',
      width: 50,
      height: 50,
      borderRadius: 25,
    };
  } else {
    return {
      backgroundColor: '#44AA44',
      width: 40,
      height: 40,
      borderRadius: 20,
    };
  }
};
```

## 성능 최적화 팁

<Callout type="tip">
  **성능 최적화를 위한 권장사항:**

  1. **적절한 클러스터 반경 설정**: `radius` 값을 40-80 사이로 설정
  2. **최대 줌 레벨 제한**: `maxZoom`을 16 이하로 설정하여 과도한 클러스터링 방지
  3. **메모이제이션 활용**: `useMemo`를 사용하여 불필요한 재계산 방지
  4. **마커 데이터 최적화**: 화면에 표시되는 영역의 마커만 로드
</Callout>

### 화면 영역 기반 마커 필터링

```tsx filename="ViewportBasedFiltering.tsx"
const useViewportMarkers = (allMarkers: MarkerData[], region: Region) => {
  return useMemo(() => {
    const padding = 0.1; // 화면 영역 패딩

    return allMarkers.filter(marker => {
      return (
        marker.latitude >= region.latitude - region.latitudeDelta - padding &&
        marker.latitude <= region.latitude + region.latitudeDelta + padding &&
        marker.longitude >= region.longitude - region.longitudeDelta - padding &&
        marker.longitude <= region.longitude + region.longitudeDelta + padding
      );
    });
  }, [allMarkers, region]);
};
```

## 문제 해결

### 클러스터가 제대로 표시되지 않는 경우
- SuperCluster 초기화 옵션 확인
- 마커 데이터 형식이 올바른지 확인
- 좌표 순서가 [longitude, latitude]인지 확인

### 성능이 느린 경우
- 클러스터링 반경을 늘려 클러스터 수 감소
- 화면 영역 기반 필터링 적용
- 마커 데이터를 청크 단위로 로드
